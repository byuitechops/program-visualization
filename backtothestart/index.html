<html>
  <head>
    <style>
      text {
        font-weight: 300;
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serf;
        font-size: 14px;
        text-anchor: middle;
        dominant-baseline:middle;
      }

      .nodes rect {
        fill:red; /* Color for Error */
      }

      .nodes g[data-type="group"] rect {
        stroke:purple;
        stroke-width:2px;
        fill:none;
      }
      
      .nodes g[data-type="course"] rect {
        fill:#00ffd0;
      }

      .edges path {
        stroke:red; /* Color for Error */
        stroke-width: 1.5px;
      }
      .edges path[data-type="pre"]{
        stroke: #333;
      }
      .edges path[data-type="co"]{
        stroke: orange;
      }
      .edges path[data-type="concur"]{
        stroke: purple;
      }
    </style>
    <script src="req-tree.js"></script>
    <script src="d3.min.js" charset="utf-8"></script>
    <script src="dagre.min.js"></script>
    <script src="ngraph.min.js"></script>
  </head>
  <body>
    <script>
      const svg = d3.select('body').append('svg')
      const $nodes = svg.append('g').classed('nodes',true)
      const $edges = svg.append('g').classed('edges',true)

      // Create the input graph
      const g = dagre.graphlib.json.read(reqTree)
        .setGraph({
          rankdir:'LR',
          nodesep:5,
          edgesep:0,
          ranksep:50,
          marginx:50,
          nwidth:100,
          nheight:20,
        })

      var comp = dagre.graphlib.alg.components(g).reduce((longest,n) => n.length>longest.length?n:longest)
      g.nodes().filter(n => !comp.includes(n)).forEach(n => g.removeNode(n))
      g.nodes().forEach(n => {
        var isCourse = g.node(n).type == 'course'
        g.node(n).width = g.graph().nwidth * isCourse
        g.node(n).height = g.graph().nheight * isCourse
      })

      g.removeNode('[]+')
      g.removeNode('[]*')

      function createGroups(){
        // TODO: Look into using tarjan instead of findCycles
        dagre.graphlib.alg.findCycles(g).forEach(cycle => {
          var isgroup = cycle.every(n => g.nodeEdges(n)
                                .filter(e => cycle.includes(e.v) && cycle.includes(e.w))
                                .every(e => g.edge(e).type == 'concur'))
          if(isgroup){
            // remove the logic nodes
            var children = cycle.filter(n => {
              if(g.node(n).type == 'logic'){
                g.removeNode(n)
                return false
              }
              return true
            })
            var name = `{${children.join(' ')}}`
            g.setNode(name,{
              type:'group',
              width:g.graph().nwidth,
              height:children.length*g.graph().nheight+(children.length-1)*g.graph().nodesep
            })
            children.forEach(child => g.setParent(child,name))
          }
        })
      }
      
      function positionLogics(){
        var slots = []

        function ranker(n){
          if(g.node(n).type == 'logic' && g.node(n).x == undefined){
            var farthest = g.predecessors(n).reduce((max,n) => Math.max(max,g.node(n).x != undefined ? g.node(n).x : ranker(n)),0)
            g.node(n).x = farthest+1
            var li = farthest%g.graph().ranksep, sx = farthest-li
            slots[sx] = slots[sx] || []
            slots[sx][li] = slots[sx][li] || []
            slots[sx][li].push(n)
          }
          return g.node(n).x || 0
        }
        function y(n){
          return g.node(n).y!=undefined?g.node(n).y:y(g.parent(n))
        }
        g.nodes().forEach(ranker)
        slots.forEach((levels,sx) => {
          levels.forEach((level,li) => {
            level.forEach(n => {
              g.node(n).x = sx+10*(li+1)
              var pres = g.predecessors(n)
              g.node(n).y = pres.map(y).reduce((a,b) => a+b,0)/pres.length
            })
          })
        })
      }

      function positionGroups(){
        g.nodes().filter(n => g.node(n).type == 'group').forEach(parent => {
          var children = g.children(parent).map(n => ({n}))
          children.forEach(p => {
            var neighbors = g.neighbors(p.n)
            p.i = neighbors.reduce((sum,n) => sum+g.node(n).y-g.node(parent).y,0)
          })
          children.sort((a,b) => a.i-b.i)
          children.forEach((p,i) => {
            g.node(p.n).x = g.node(parent).x
            g.node(p.n).y = g.node(parent).y-g.node(parent).height/2+g.node(p.n).height/2+i*(g.graph().nheight+g.graph().nodesep)
          })
        })
      }

      function adjustLogics(){
        g.nodes().filter(n => g.node(n).type == 'logic').forEach(n => {
          var neighbors = g.neighbors(n)
          g.node(n).y = neighbors.reduce((sum,n) => sum+g.node(n).y,0)/neighbors.length
        })
      }

      function layout(){
        function addEdge(v,w){
          if(clone.edge(v,w)==undefined){
            clone.setEdge(v,w,{weight:1})
          } else {
            clone.edge(v,w).weight++
          }
        }
        var clone = new dagre.graphlib.Graph()
        // Copy Graph
        clone.setGraph(g.graph())
        g.nodes().forEach(n => clone.setNode(n,g.node(n)))
        g.edges().forEach(({v,w}) => clone.setEdge(v,w,g.edge(v,w)))
        // Make changes
        g.nodes().filter(n => g.node(n).type=='logic').forEach(n => {
          var edges = clone.nodeEdges(n)
          // console.log(edges)
          // var weight = edges.reduce((sum,{v,w}) => sum+(clone.edge(v,w).weight||1),0)/(edges.length-1)
          // console.log(weight,n)
          clone.predecessors(n).forEach(pre => clone.successors(n).forEach(suc => clone.setEdge(pre,suc,{})))
          clone.removeNode(n)
        })
        g.nodes().filter(n => g.node(n).type=='group').forEach(n => {
          g.children(n).forEach(child => {
            clone.inEdges(child).forEach(({v,w}) => addEdge(v,n))
            clone.outEdges(child).forEach(({v,w}) => addEdge(n,w))
            clone.removeNode(child)
          })
        })
        // layout the clone
        dagre.layout(clone)
        // adding the removed components back in
        positionLogics()
        positionGroups()
        adjustLogics()
        routing()
        // render(clone)
      }

      function pather(r){
        // copy this graph
        var rgraph = ngraph.graph()
        r.nodes().forEach(n => rgraph.addNode(n))
        r.edges().forEach(e => rgraph.addLink(e.v,e.w,r.edge(e)))
        var current
        var none = {weight:Number.POSITIVE_INFINITY}
        var PathFinder = ngraph.path.nba(rgraph,{
          distance(v,w,l){
            return (r.edge(v.id,w.id) || r.edge(v.id,w.id,current) || none).weight
          }
        })
        g.edges().forEach(e => {
          current = e.v
          g.edge(e).path = PathFinder.find(e.w,e.v).map(n => n.id)
          g.edge(e).path.reduce((v,w) => {
            if(!r.edge(v,w,current)){
              r.setEdge(v,w,r.edge(v,w),current)
            }
            return w
          })
        })
      }

      function routesrender(r){
        const $routes = svg.append('g')
        $routes.append('g').selectAll('line')
          .data(r.edges())
          .enter().append('line')
            // .attr('stroke-width',e => r.nodeEdges(e.v,e.w).length)
            .attr('stroke-opacity',e => e.name && r.edge(e.v,e.w,e.name) ? 0.5 : 0)
            .attr('stroke',e => e.name && r.edge(e.v,e.w,e.name) ? 'black' : 'red')
            .attr('x1',e => r.node(e.v).x)
            .attr('y1',e => r.node(e.v).y)
            .attr('x2',e => r.node(e.w).x)
            .attr('y2',e => r.node(e.w).y)
        // $routes.append('g').selectAll('circle')
        //   .data(r.nodes())
        //   .enter().append('circle')
        //     .attr('data-id',n => n)
        //     .attr('fill',n => ({route:'black',course:'red',logic:'red',mid:'purple'})[r.node(n).type])
        //     .attr('fill-opacity',n => r.node(n).type=='route' ? 1 : 1)
        //     .attr('r',n => r.node(n).type=='route' ? 2 : 2)
        //     .attr('cx',n => r.node(n).x)
        //     .attr('cy',n => r.node(n).y)
      }
      
      function routing(){
        var r = new dagre.graphlib.Graph({multigraph:true,directed:false})
        window.r = r
        
        function addNode(x,y){
          var n = x+','+y
          r.setNode(n,{type:'route',x:x,y:y})
          return n
        }
        function addEdge(p1,p2,name){
          r.setEdge(p1,p2,{weight:Math.abs(r.node(p1).x-r.node(p2).x)+Math.abs(r.node(p1).y-r.node(p2).y)},name)
        }

        // Copy Graph
        g.nodes().filter(n => g.node(n).type != 'group').forEach(n => r.setNode(n,g.node(n)))
        
        var nodes = r.nodes().map(n => ({n,...g.node(n)})).sort((a,b) => a.y-b.y)
        nodes.reduce((lasts,node) => {
          lasts[node.x] = lasts[node.x] || node
          if(node.y-lasts[node.x].y>g.graph().nheight*2 && node.type=='course'){
            var mid = {
              y:(node.y+lasts[node.x].y)/2,
              x:node.x,
              n:node.n+'~'+lasts[node.x].n,
              type:'mid',
            }
            nodes.push(mid)
            r.setNode(mid.n,mid)
          }
          lasts[node.x] = node
          return lasts
        },{})
        nodes.sort((a,b) => a.y-b.y)
        var grid = Object.values(nodes.reduce((grid,n) => {
          if(grid[n.x] == undefined){
            grid[n.x] = {
              x:n.x,
              type:n.type,
            }
          }
          return grid
        },{})).sort((a,b) => a.x-b.x)
        window.grid = grid

        var memory = []
        grid.forEach((col,ci) => {
          if(col.type=='course' && memory.length){
            /* Node connections */
            nodes.filter(node => node.x >= grid[ci-memory.length-1].x && node.x <= col.x).forEach((node,ni) => {
              if(ni == 0){
                memory = memory.map(x => addNode(x,node.y))
              }
              for(var mi = 0,created,i; mi < memory.length; ++mi){
                i = ci-memory.length+mi
                created = grid[i].x == node.x ? node.n : addNode(grid[i].x,node.y)
                addEdge(memory[mi],created)
                mi && addEdge(memory[mi-1],created,memory[mi-1]==node.n?node.n:undefined)
                memory[mi] = created
              }
              // Front node connections
              if(grid[ci-memory.length-1].x == node.x){
                addEdge(node.n,memory[0],node.type=="mid"?undefined:node.n)
              }
              // Back node connections
              if(grid[ci].x == node.x){
                addEdge(memory[memory.length-1],node.n)
              }
            })
            memory = []
            last = 0
          } else if(col.type=='logic'){
            memory.push(col.x)
          }
        })

        pather(r)
        routesrender(r)
        render(g)
      }

      function render(g){
        const $nodes = svg.append('g').classed('nodes',true)
        const $edges = svg.append('g').classed('edges',true)
        // Create Joined Data selections
        var _nodes = $nodes.selectAll('g')
          .data(g.nodes(),function(d){ return d ? d : this.getAttribute('data-id') })
        var _edges = $edges.selectAll('path')
          .data(g.edges(),function(d){ return d ? d.v+'-'+d.w : this.getAttribute('data-source')+'-'+this.getAttribute('data-target') })
        
        // _edges.enter().append('path')
        //   .attr('data-source',d => d.v)
        //   .attr('data-target',d => d.w)
        //   .attr('data-type',d => g.edge(d.v,d.w).type)
        // .merge(_edges)
        //   .attr('d',d => {
        //     var s = g.node(d.v)
        //     var t = g.node(d.w)
        //     // return describeLine(s.x,s.y,t.x,t.y)
        //     return [
        //       'M',s.x,s.y,
        //       'L',t.x-t.width,t.y,
        //     ].join(' ')
        //   })
        // _edges.exit().remove()

        // Update elements with the new calculations
        var enteringNodes = _nodes.enter().append('g')
          .attr('data-id',d => d)
          .attr('data-type',d => g.node(d).type)
        enteringNodes.append('rect')
          .attr('width',d => g.node(d).width)
          .attr('height',d => g.node(d).height)
        enteringNodes.append('text')
          .attr('x',d => g.node(d).width/2)
          .attr('y',d => g.node(d).height/2)
          .text(d => g.node(d).type == 'course' ? d : '')
        enteringNodes
        .merge(_nodes)
          .attr('transform',d => `translate(${[g.node(d).x-g.node(d).width,g.node(d).y-g.node(d).height/2]})`)
        _nodes.exit().remove()

        svg
          .attr('width',g.graph().width)
          .attr('height',g.graph().height)
      }
      
      createGroups()
      layout()
      // render(g)
    </script>
  </body>
</html>